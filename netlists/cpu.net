# Initialisation de PC à partir de PC_REG
PC = BUF:16 PC_REG

INSTRUCTION = ROM PC

OPCODE = SUB INSTRUCTION 0 5

DO_WRITE = NOT OPCODE[5]
NO_ALU = INDEX OPCODE 4
NOT_OPCODE_3 = NOT OPCODE[3]
DO_JUMP = AND NO_ALU NOT_OPCODE_3
DO_RAM = AND NO_ALU OPCODE[3]
USE_CONSTANTE = INDEX OPCODE 0
NOT_USE_CONSTANTE = NOT USE_CONSTANTE

ALU_CODE = SUB OPCODE 1 3

CONSTANTE = SUB INSTRUCTION 16 31

R1CODE = SUB INSTRUCTION 6 9
R2CODE = SUB INSTRUCTION 14 17
ROUTCODE = SUB INSTRUCTION 10 13


FOR i IN 0 TO 15:
    R{i} = BUF:16 R{i}_TMP
    R{i}_TMP = BUF R{i}
END

EQ_FLAG = BUF:1 EQ_FLAG_REG
OVERFLOW = BUF:1 OVERFLOW_REG
OVERFLOW_REG = CONST 0

SEL = BUF R1CODE

# On suppose que les R0 à R15 sont déjà déclarés

# Étape 1 : 16 → 8, contrôlée par SEL[0]
FOR i IN 0 TO 7:
    MUX1_{i} = MUX SEL[0] R{2*i} R{2*i+1}
END

# Étape 2 : 8 → 4, contrôlée par SEL[1]
FOR i IN 0 TO 3:
    MUX2_{i} = MUX SEL[1] MUX1_{2*i} MUX1_{2*i+1}
END

# Étape 3 : 4 → 2, contrôlée par SEL[2]
FOR i IN 0 TO 1:
    MUX3_{i} = MUX SEL[2] MUX2_{2*i} MUX2_{2*i+1}
END

# Étape 4 : 2 → 1, contrôlée par SEL[3]
R_SELECTED = MUX SEL[3] MUX3_0 MUX3_1


GHOST NOT_USE_CONSTANTE

SEL2 = BUF R2CODE

# On suppose que les R0 à R15 sont déjà déclarés

# Étape 1 : 16 → 8, contrôlée par SEL[0]
FOR i IN 0 TO 7:
    MUX1_{i} = MUX SEL2[0] R{2*i} R{2*i+1}
END

# Étape 2 : 8 → 4, contrôlée par SEL[1]
FOR i IN 0 TO 3:
    MUX2_{i} = MUX SEL2[1] MUX1_{2*i} MUX1_{2*i+1}
END

# Étape 3 : 4 → 2, contrôlée par SEL[2]
FOR i IN 0 TO 1:
    MUX3_{i} = MUX SEL2[2] MUX2_{2*i} MUX2_{2*i+1}
END

# Étape 4 : 2 → 1, contrôlée par SEL[3]
R_SELECTED2 = MUX SEL2[3] MUX3_0 MUX3_1

GHOST_END



A = BUF R_SELECTED
B = MUX USE_CONSTANTE R_SELECTED2 CONSTANTE
OP = BUF ALU_CODE

C0 = INDEX OP 0
NB = NOT B
NOTDOADD = OR OP[1] OP[2]
DO_ADD = NOT NOTDOADD

GHOST DO_ADD

GOODB = MUX C0 B NB

FOR i IN 0 TO 15:
    S{i}_X  = XOR A[{i}] GOODB[{i}]
    SU{i}    = XOR S{i}_X C{i}
    C{i+1}_A = AND A[{i}] GOODB[{i}]
    C{i+1}_B = AND S{i}_X C{i}
    C{i+1}   = OR C{i+1}_A C{i+1}_B
END

OVERFLOW_REG = BUF SU15

#code = 000,001
RESULT_SUM = CONCAT SU15 SU14 SU13 SU12 SU11 SU10 SU9 SU8 SU7 SU6 SU5 SU4 SU3 SU2 SU1 SU0

GHOST_END

#code = 010
MUL_COND1 = NOT OP[0]
MUL_COND2 = NOT OP[2]
MUL_COND3 = INDEX OP 1
MUL_COND4 = AND MUL_COND1 MUL_COND2
MUL = AND MUL_COND4 MUL_COND3

GHOST MUL

FOR i IN 0 TO 15:
    PART{i} = MUX B[{i}] ZERO A
    IF i == 0:
        SHIFTED{i} = BUF PART{i}
    ELSE:
        SHIFTED{i} = CONCAT PART{i} {i * '0'}
    ENDIF
    S{i} = SUB SHIFTED{i} 0 15
END

ACC0 = BUF S0
C0_0 = CONST 0

FOR i IN 0 TO 14:
    FOR j IN 0 TO 15:
        A_{i}_{j} = INDEX ACC{i} {j}
        B_{i}_{j} = INDEX S{i+1} {j}
        SX_{i}_{j} = XOR A_{i}_{j} B_{i}_{j}
        S_{i}_{j}  = XOR SX_{i}_{j} C{i}_{j}
        CA_{i}_{j} = AND A_{i}_{j} B_{i}_{j}
        CB_{i}_{j} = AND SX_{i}_{j} C{i}_{j}
        C{i}_{j+1} = OR CA_{i}_{j} CB_{i}_{j}
    END
    ACC{i+1} = CONCAT S_{i}_15 S_{i}_14 S_{i}_13 S_{i}_12 S_{i}_11 S_{i}_10 S_{i}_9 S_{i}_8 S_{i}_7 S_{i}_6 S_{i}_5 S_{i}_4 S_{i}_3 S_{i}_2 S_{i}_1 S_{i}_0
END

RESULT_MUL = BUF ACC15

GHOST_END

#code 100,101,110,111
AND_RESULT = AND A B
OR_RESULT = OR A B
XOR_RESULT = XOR A B

AND_OR_RESULT = MUX OP[0] AND_RESULT OR_RESULT
XOR_CONST_RESULT = MUX OP[0] XOR_RESULT A
EZ_RESULT = MUX OP[1] AND_OR_RESULT XOR_CONST_RESULT

MUL_CONST_RESULT = MUX OP[0] RESULT_MUL B
HARD_RESULT = MUX OP[1] RESULT_SUM MUL_CONST_RESULT

ALU_RESULT = MUX OP[2] HARD_RESULT EZ_RESULT

DONT_WRITE = NOT DO_WRITE
STORE_RAM = AND DO_RAM DONT_WRITE
LOAD_RAM0 = AND DO_RAM DO_WRITE
LOAD_ROM = AND LOAD_RAM0 OPCODE[2]
NOT_LOAD_ROM = NOT LOAD_ROM
LOAD_RAM = AND LOAD_RAM0 NOT_LOAD_ROM

GHOST LOAD_RAM
RAM_RESULT = LOAD B
GHOST_END

GHOST LOAD_ROM
ROM_RESULT0 = ROM B
ROM_RESULT1 = SUB ROM_RESULT0 0 15
ROM_RESULT2 = SUB ROM_RESULT0 16 31
RAM_RESULT = MUX OPCODE[1] ROM_RESULT1 ROM_RESULT2
GHOST_END

GHOST STORE_RAM
_ = STORE B A
GHOST_END

RESULT = MUX LOAD_RAM0 ALU_RESULT RAM_RESULT


EQ_OR_0 = INDEX RESULT 0
FOR i IN 1 TO 15:
    EQ_OR_{i} = OR EQ_OR_{i-1} RESULT[{i}]
END

EQ_FLAG_REG = NOT EQ_OR_15


GHOST DO_WRITE

FOR i IN 0 TO 15:
    CONST_{i} = CONST {format(i, '04b')}
    DIFF_{i} = XOR ROUTCODE CONST_{i}
    CODE_MATCH_{i} = NOT DIFF_{i}
    DOGHOST1_{i} = AND CODE_MATCH_{i}[0] CODE_MATCH_{i}[1]
    DOGHOST2_{i} = AND CODE_MATCH_{i}[2] CODE_MATCH_{i}[3]
    DOGHOST_{i} = AND DOGHOST1_{i} DOGHOST2_{i}

    R{i}_TMP = MUX DOGHOST_{i} R{i} RESULT
END

GHOST_END

#011 = over, 001 = eq, 000 = toujours
COND_JUMP = MUX ALU_CODE[1] EQ_FLAG OVERFLOW
NOT_ALU_0 = NOT ALU_CODE[0]
IF_JUMP = OR NOT_ALU_0 COND_JUMP
ACTUAL_JUMP = AND DO_JUMP IF_JUMP
NO_ACTUAL_JUMP = NOT ACTUAL_JUMP

GHOST NO_ACTUAL_JUMP

# Constante 1 (16 bits)
PC_INC_ONE = CONST 0000000000000001
PC_INC_ZERO = CONST 0000000000000000

# Addition simple : PC_NEXT = PC + 1 (ripple carry 16 bits)
PC_INC_C0 = CONST 0

FOR i IN 0 TO 15:
    PC_INC_A{i} = INDEX PC {i}
    PC_INC_B{i} = INDEX PC_INC_ONE {i}
    PC_INC_X{i} = XOR PC_INC_A{i} PC_INC_B{i}
    PC_INC_S{i} = XOR PC_INC_X{i} PC_INC_C{i}
    PC_INC_C{i}_A = AND PC_INC_A{i} PC_INC_B{i}
    PC_INC_C{i}_B = AND PC_INC_X{i} PC_INC_C{i}
    PC_INC_C{i+1} = OR PC_INC_C{i}_A PC_INC_C{i}_B
END

PC_NEXT = CONCAT PC_INC_S15 PC_INC_S14 PC_INC_S13 PC_INC_S12 PC_INC_S11 PC_INC_S10 PC_INC_S9 PC_INC_S8 PC_INC_S7 PC_INC_S6 PC_INC_S5 PC_INC_S4 PC_INC_S3 PC_INC_S2 PC_INC_S1 PC_INC_S0

GHOST_END

# Enregistre le nouveau PC
PC_REG = MUX ACTUAL_JUMP PC_NEXT B

# Pour vérification
#OUTPUT RESULT EQ_FLAG OVERFLOW PC_REG
